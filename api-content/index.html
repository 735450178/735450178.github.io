{"posts":[{"title":"Docker容器迁移","content":"一次Docker容器迁移教学记录 笔者本人之前使用的腾讯云的轻量云服务器，使用期限为一年，大部分的服务都是以Docker容器的方式，跑在这个服务器上的。中途偶然白嫖阿里轻量云十年的使用期限🫣，所以就有了这篇Docke容器迁移的教程，希望能给有类似需求的朋友一点借鉴。 一、打包容器 首先需要将要迁移的容器打包，可以通过docker ps 命令查看目前运行的docker 容器 #查看正在运行的容器 docker ps #导出容器为gz文件 下面的命令需要替换container-name为自己的容器名称 docker export container-name gzip container-name.gz 当我们完成上面操作的时候将会在当前文件夹下得到一个container-name.gz的文件，这个文件就是打包好的容器 二、传输容器 接下来我们就需要转移容器，转移容器有一下几种方法： 使用scp命令，就是secure copy，是用来进行远程文件拷贝的 需要两台主机能互通网络 优点：不耗费本地流量 使用方法： #scp [参数] &lt;源地址（用户名@IP地址或主机名）&gt;:&lt;文件路径&gt; &lt;目的地址（用户名 @IP 地址或主机名）&gt;:&lt;文件路径&gt; scp container-name.gz root@1.1.1.1:/docker 使用wget命令，当两台主机不能直接网络互通 可以通过本机作为跳板机 来下载和导入文件。wget主要用于下载文件，上传文件需要结合scp命令使用 使用方法： #wget 用户名@IP地址或主机名:&lt;文件路径&gt; #将container-name.gz文件下载至本地 wget root@2.2.2.2:/path/container-name.gz #使用scp将文件从本机复制到目标主机 scp container-name.gz root@1.1.1.1:/docker 三、导入容器 将上传好的容器导入就能实现容器的迁移 #docker import &lt;导出的文件名&gt;.gz &lt;新容器名称&gt; docker import container-name.gz container-name #运行容器 docker run -p 80:80 container-name ","link":"https://uniqueww.github.io/post/docker-rong-qi-qian-yi/"},{"title":"Spring面试题","content":"什么？！Spring来了，又到了万物复苏的季节🌱 ","link":"https://uniqueww.github.io/post/spring面试题/"},{"title":"Java基础面试题","content":"一些Java面试题目的整理，八股取士，得八股文者得工作😄 ArrayList和LinkedList的区别 内部实现：ArrayList是基于动态数组实现的，内部使用Object[]数组来存储元素。而LinkedList是基于双向链表实现的，内部使用Node节点来存储元素 插入和删除操作：ArrayList对于中间位置的插入和删除需要移动元素，因为它的底层是数组，需要将后面的元素往后移动，而LinkedList只需要修改节点的指针即可。因此，LinkedList在插入和删除操作方面比ArrayList效率更高 随机访问：由于ArrayList的底层是数组，所以可以根据下标快速随机访问元素，时间复杂度为O(1)；而LinkedList是基于链表实现的，不能直接根据下标访问元素，需要从头或者从尾遍历到指定位置，时间复杂度为O(n)。 内存占用：由于LinkedList的每个元素都需要一个额外指针来指向下一个节点，因此占用的内存空间会比ArrayList多 双亲委派模式 当一个类加载器需要去加载一个类时，它不会直接去加载这个类，而是委派自己的父类去加载，当自己的父类都无法加载时才会自己加载。这样做防止了对 Java核心类库的篡改。 类加载器的分类： 类加载器 作用 BootStrap ClassLoad 根加载器 负责Java核心类库的加载 JDK或者是JRE中的lib Extension ClassLoad 拓展类加载器 负责加载JRE中lib包下的ext包中的jar包 Application ClassLoad 应用程序加载器 负责加载当前应用程序中classpath下的所有类 User ClassLoad 用户自定义加载器 负责加载用户指定的class文件 String、StringBuilder、StringBuffer的区别 String 的底层是一个被finnal修饰的字符数组。如下图，所以他是不可变得，每次+操作其实是新建了一个跟原字符串相同的StringBuilder对象执行append()方法。 private final char value[]; StringBuffer和StringBuilder的底层都是可变的字符数组 private char value[]; 不同的是StringBuffer是线程安全的，而StringBuilder不是。这是由于StringBuffer的内部方法都是由sychronized关键字修饰的，代码在执行时都会加锁。 ··· @Override public synchronized StringBuffer append(long lng) { toStringCache = null; super.append(lng); return this; } @Override public synchronized StringBuffer append(float f) { toStringCache = null; super.append(f); return this; } ··· ArrayList、LinkedList、Vector的概述与主要区别 想要充分理解三者的区别需要先了解数组（动态数组） 以及链表的区别 数组：有序元素的集合，是内存上一片连续的内存地址，你可以理解为一个连续的从0到n到台阶。 动态数组：当指定的存储空间不够时会自动扩容为原来的1.5倍 链表：物理存储上一种非连续、非顺序的存储结构，只能通过指针顺序访问，不支持随机问，类似于剧本杀只有一条线索，每次只能通过当前的线索来找出下一条线索。 ArraList是基于数组实现的，支持随机访问以及null值的存储，在get方面的set方面的速度最快，但是因为其有序性，在add和delete时可能存在需要移动数组中的大部分元素，造成性能较差。所以适合新增删除次数少，读取频率较高的场景。 LinkedList时基于链表实现的，指出null值的存储，链表在读取的时候时间复杂度为O(n) ,读取的性能较差，只支持链式读取，不支持随机访问。但在新增和删除时只需要修改指针的指向而不需要移动元素，所以在add和delete时性能较高。适合在增删比较频繁，读取次数较少的场景。 Vector也是基于动态数组实现的，与ArrayList不同的是Vector中的所有方法都是被sychronized修饰的，所以他是县城安全的，但是在单线程模式下，性能比AraayList差，适用于多线程环境保障数据一致性。 AraayList、LinkedList、vector都实现了List接口 注：ArrayList和LinkedList想在多线程环境下使用，也可以在创建时使用 List list = Collections.synchronizedList(new ArrayList(...)); HashMap、HashTable、CurrentHashmap、TreeMap、HashSet的概述和区别 这些都是面试常问到的Map相关的类，同样在分析他们之前，需要先了解一些基础的数据结构 给出一个详细的推荐文章 二叉树：二叉树的定义是 每个节点最多只有两个子节点 二叉查找树：在二叉树的基础上多了一个限制 左边的子节点比右边的子节点要小 平衡二叉树：在极端情况下，比如二叉树的大部分子节点都比根节点要小/大，则二叉树会退化为链表。为了避免出现这种情况，平衡二叉树在二叉查找树大基础上又多了一个限制 每个节点的左右两子树的高度差至多为1 红黑树：平衡二叉树高度差至多为1的条件过于严格，导致每次add和delete的时候都需要经过大量的比较，性能较差，所以衍生出了红黑树。红黑树的特点： 具有二叉树的所有特点 每个节点要么是红色要么是黑色 根节点只能为黑色 黑色节点不存储数据 任何两个红色节点不能直接相连（所有的红色节点都被黑色节点分隔开） B树：自平衡的多叉树，可以解决在数据量大是平衡二叉树的深度过深导致性能低下，适用于需要读取和写入较大数据块的存储系统。通常用于数据库和文件系统 B+树：是对B树对一种优化，叶子节点存储数据，它的非叶子节点只存储索引不存储数据，这就能使非叶子节点存储更多的索引数据，从而降低树整体的高度，优化读取IO次数，查询速度更快。 HashMap：在JDK1.8之前他的数据结构式数组+链表 ，在JDK1.8之后当链表的长度超过8则会转为红黑树。它的工作原理为，当put一个键值对时，使用key进行hash计算得到一个hash值，通过hash值对数组长度取模，会得出一个在数组长度内的int值i，最后将该键值对存储在这数组索引为i的位置上，如果这个位置已有元素，则通过链表的形式上去。 HashTable：和HashMap基本一致的数据结构，只不过类里面的方法都加上的sychronized关键字。是线程安全的，这也导致它的性能比HashMap较低。 CurrentHashMap：通过分段锁的形式提升了性能，并且是线程安全的。 TreeMap：基于红黑树实现，TreeMap的Key按照自然顺序进行排序或者根据创建映射时提供的Comparator接口进行排序。适用于需要排序的场景。 HashSet：HashSet底层也是HashMap存储，元素不可重复。 总结：HashMap和currentHashmap允许key和value为null，hashTable不允许key和value为null，TreeMap只允许value为null，key不能为null。HashSet允许存储一个null元素。 ","link":"https://uniqueww.github.io/post/java面试题/"}]}